From d806f899c772642b76a673e3a0f910c8a9fc6ce1 Mon Sep 17 00:00:00 2001
From: Bret Curtis <psi29a@gmail.com>
Date: Wed, 17 Jun 2020 19:04:26 +0200
Subject: [PATCH] Using bzzts original terrain occlusion branch as a start,
 refactored to work with OSG 3.6 and latest changes

---
 apps/openmw/mwrender/localmap.cpp          |   1 +
 apps/openmw/mwrender/objects.cpp           |  20 ++++
 apps/openmw/mwrender/renderingmanager.cpp  |   4 +
 apps/openmw/mwrender/water.cpp             |  26 +++++
 components/sceneutil/mwshadowtechnique.cpp |   1 +
 components/terrain/chunkmanager.cpp        |   2 +
 components/terrain/quadtreeworld.cpp       | 109 +++++++++++++++++++--
 components/terrain/quadtreeworld.hpp       |   9 ++
 components/terrain/terraindrawable.cpp     |  92 +++++++++++++++++
 components/terrain/terraindrawable.hpp     |   5 +
 files/settings-default.cfg                 |  19 ++++
 11 files changed, 279 insertions(+), 9 deletions(-)

diff --git a/apps/openmw/mwrender/localmap.cpp b/apps/openmw/mwrender/localmap.cpp
index 5fa1a0e299..3f920a209e 100644
--- a/apps/openmw/mwrender/localmap.cpp
+++ b/apps/openmw/mwrender/localmap.cpp
@@ -180,6 +180,7 @@ osg::ref_ptr<osg::Camera> LocalMap::createOrthographicCamera(float x, float y, f
     camera->setClearColor(osg::Vec4(0.f, 0.f, 0.f, 1.f));
     camera->setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     camera->setRenderOrder(osg::Camera::PRE_RENDER);
+    camera->setCullingMode(osg::CullSettings::VIEW_FRUSTUM_SIDES_CULLING);
 
     camera->setCullMask(Mask_Scene | Mask_SimpleWater | Mask_Terrain | Mask_Object | Mask_Static);
     camera->setNodeMask(Mask_RenderToTexture);
diff --git a/apps/openmw/mwrender/objects.cpp b/apps/openmw/mwrender/objects.cpp
index ec1c4397bf..6aeb12f0c5 100644
--- a/apps/openmw/mwrender/objects.cpp
+++ b/apps/openmw/mwrender/objects.cpp
@@ -1,5 +1,7 @@
 #include "objects.hpp"
 
+#include <osgUtil/CullVisitor>
+
 #include <osg/Group>
 #include <osg/UserDataContainer>
 
@@ -14,6 +16,21 @@
 #include "creatureanimation.hpp"
 #include "vismask.hpp"
 
+class OcclusionActivateCallback : public osg::NodeCallback
+{
+public:
+    virtual void operator()(osg::Node* node, osg::NodeVisitor* nv)
+    {
+        osgUtil::CullVisitor* cv = static_cast<osgUtil::CullVisitor*>(nv);
+        if (cv->getCullingMode() & osg::CullSettings::SHADOW_OCCLUSION_CULLING)
+            cv->pushCullingSet();
+
+        traverse(node, nv);
+
+        if (cv->getCullingMode() & osg::CullSettings::SHADOW_OCCLUSION_CULLING)
+            cv->popCullingSet();
+    }
+};
 
 namespace MWRender
 {
@@ -44,6 +61,7 @@ void Objects::insertBegin(const MWWorld::Ptr& ptr)
     if (found == mCellSceneNodes.end())
     {
         cellnode = new osg::Group;
+        cellnode->addCullCallback(new OcclusionActivateCallback);
         cellnode->setName("Cell Root");
         mRootNode->addChild(cellnode);
         mCellSceneNodes[ptr.getCell()] = cellnode;
@@ -183,6 +201,8 @@ void Objects::updatePtr(const MWWorld::Ptr &old, const MWWorld::Ptr &cur)
     osg::Group* cellnode;
     if(mCellSceneNodes.find(newCell) == mCellSceneNodes.end()) {
         cellnode = new osg::Group;
+        cellnode->addCullCallback(new OcclusionActivateCallback);
+        cellnode->setName("Cell Root");
         mRootNode->addChild(cellnode);
         mCellSceneNodes[newCell] = cellnode;
     } else {
diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index 6ba4baec54..15ff3ac38d 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -290,6 +290,7 @@ namespace MWRender
             mTerrain.reset(new Terrain::QuadTreeWorld(
                 sceneRoot, mRootNode, mResourceSystem, mTerrainStorage.get(), Mask_Terrain, Mask_PreCompile, Mask_Debug,
                 compMapResolution, compMapLevel, lodFactor, vertexLodMod, maxCompGeometrySize));
+            static_cast<Terrain::QuadTreeWorld*>(mTerrain.get())->setOcclusionCullingSettings(Settings::Manager::getBool("debug occlusion culling", "Terrain"), Settings::Manager::getInt("occlusion culling maximum active", "Terrain"), Settings::Manager::getFloat("occlusion culling minimum volume", "Terrain"), Settings::Manager::getFloat("occlusion culling zfactor", "Terrain"), Settings::Manager::getFloat("occlusion culling zbias", "Terrain"));
             if (Settings::Manager::getBool("object paging", "Terrain"))
             {
                 mObjectPaging.reset(new ObjectPaging(mResourceSystem->getSceneManager()));
@@ -379,6 +380,9 @@ namespace MWRender
 
         osg::Camera::CullingMode cullingMode = osg::Camera::DEFAULT_CULLING|osg::Camera::FAR_PLANE_CULLING;
 
+        if (!Settings::Manager::getBool("occlusion culling", "Terrain"))
+            cullingMode &= ~(osg::CullStack::SHADOW_OCCLUSION_CULLING);
+
         if (!Settings::Manager::getBool("small feature culling", "Camera"))
             cullingMode &= ~(osg::CullStack::SMALL_FEATURE_CULLING);
         else
diff --git a/apps/openmw/mwrender/water.cpp b/apps/openmw/mwrender/water.cpp
index 1cc5a3cb7c..9dcbad7d8d 100644
--- a/apps/openmw/mwrender/water.cpp
+++ b/apps/openmw/mwrender/water.cpp
@@ -2,6 +2,7 @@
 
 #include <iomanip>
 
+#include <osg/PolygonMode>
 #include <osg/Fog>
 #include <osg/Depth>
 #include <osg/Group>
@@ -244,6 +245,18 @@ public:
         setCullCallback(new InheritViewPointCallback);
         setComputeNearFarMode(osg::CullSettings::DO_NOT_COMPUTE_NEAR_FAR);
 
+        osg::Camera::CullingMode cullingMode = osg::Camera::DEFAULT_CULLING|osg::Camera::FAR_PLANE_CULLING;
+        cullingMode &= ~(osg::CullStack::SHADOW_OCCLUSION_CULLING);
+
+        if (!Settings::Manager::getBool("small feature culling", "Camera"))
+            cullingMode &= ~(osg::CullStack::SMALL_FEATURE_CULLING);
+        else
+        {
+            cullingMode |= osg::CullStack::SMALL_FEATURE_CULLING;
+            setSmallFeatureCullingPixelSize(Settings::Manager::getInt("small feature culling pixel size", "Water"));
+        }
+        setCullingMode(cullingMode);
+
         setCullMask(Mask_Effect|Mask_Scene|Mask_Object|Mask_Static|Mask_Terrain|Mask_Actor|Mask_ParticleSystem|Mask_Sky|Mask_Sun|Mask_Player|Mask_Lighting|Mask_Groundcover);
         setNodeMask(Mask_RenderToTexture);
         setViewport(0, 0, rttSize, rttSize);
@@ -338,6 +351,19 @@ public:
         osg::Camera::setName("ReflectionCamera");
         setCullCallback(new InheritViewPointCallback);
 
+        osg::Camera::CullingMode cullingMode = osg::Camera::DEFAULT_CULLING|osg::Camera::FAR_PLANE_CULLING;
+        if (!Settings::Manager::getBool("reflection occlusion culling", "Terrain"))
+            cullingMode &= ~(osg::CullStack::SHADOW_OCCLUSION_CULLING);
+
+        if (!Settings::Manager::getBool("small feature culling", "Camera"))
+            cullingMode &= ~(osg::CullStack::SMALL_FEATURE_CULLING);
+        else
+        {
+            cullingMode |= osg::CullStack::SMALL_FEATURE_CULLING;
+            setSmallFeatureCullingPixelSize(Settings::Manager::getInt("small feature culling pixel size", "Water"));
+        }
+        setCullingMode(cullingMode);
+
         setInterior(isInterior);
         setNodeMask(Mask_RenderToTexture);
 
diff --git a/components/sceneutil/mwshadowtechnique.cpp b/components/sceneutil/mwshadowtechnique.cpp
index 294780cfd7..0aca562edb 100644
--- a/components/sceneutil/mwshadowtechnique.cpp
+++ b/components/sceneutil/mwshadowtechnique.cpp
@@ -583,6 +583,7 @@ MWShadowTechnique::ShadowData::ShadowData(MWShadowTechnique::ViewDependentData*
 
     // switch off small feature culling as this can cull out geometry that will still be large enough once perspective correction takes effect.
     _camera->setCullingMode(_camera->getCullingMode() & ~osg::CullSettings::SMALL_FEATURE_CULLING);
+    _camera->setCullingMode(_camera->getCullingMode() & ~osg::CullSettings::SHADOW_OCCLUSION_CULLING);
 
     // set viewport
     _camera->setViewport(0,0,textureSize.x(),textureSize.y());
diff --git a/components/terrain/chunkmanager.cpp b/components/terrain/chunkmanager.cpp
index a744471de5..d732cb24a0 100644
--- a/components/terrain/chunkmanager.cpp
+++ b/components/terrain/chunkmanager.cpp
@@ -234,6 +234,8 @@ osg::ref_ptr<osg::Node> ChunkManager::createChunk(float chunkSize, const osg::Ve
     }
     geometry->setNodeMask(mNodeMask);
 
+    geometry->createOccluders(chunkCenter * mStorage->getCellWorldSize());
+
     return geometry;
 }
 
diff --git a/components/terrain/quadtreeworld.cpp b/components/terrain/quadtreeworld.cpp
index 7f184c70eb..30bc5f388e 100644
--- a/components/terrain/quadtreeworld.cpp
+++ b/components/terrain/quadtreeworld.cpp
@@ -3,6 +3,7 @@
 #include <osgUtil/CullVisitor>
 #include <osg/ShapeDrawable>
 #include <osg/PolygonMode>
+#include <osg/Material>
 
 #include <limits>
 #include <sstream>
@@ -244,6 +245,9 @@ private:
 QuadTreeWorld::QuadTreeWorld(osg::Group *parent, osg::Group *compileRoot, Resource::ResourceSystem *resourceSystem, Storage *storage, int nodeMask, int preCompileMask, int borderMask, int compMapResolution, float compMapLevel, float lodFactor, int vertexLodMod, float maxCompGeometrySize)
     : TerrainGrid(parent, compileRoot, resourceSystem, storage, nodeMask, preCompileMask, borderMask)
     , mViewDataMap(new ViewDataMap)
+    , mDebugOccluders(false)
+    , mOcclusionCullingZFactor(0)
+    , mOcclusionCullingZBias(0)
     , mQuadTreeBuilt(false)
     , mLodFactor(lodFactor)
     , mVertexLodMod(vertexLodMod)
@@ -254,6 +258,21 @@ QuadTreeWorld::QuadTreeWorld(osg::Group *parent, osg::Group *compileRoot, Resour
     mChunkManager->setCompositeMapLevel(compMapLevel);
     mChunkManager->setMaxCompositeGeometrySize(maxCompGeometrySize);
     mChunkManagers.push_back(mChunkManager.get());
+
+    mCollectOccludersVisitor = new osg::CollectOccludersVisitor;
+}
+
+void QuadTreeWorld::setOcclusionCullingSettings(bool debug, int maximumActive, float minimumVolume, float zfactor, float zbias)
+{
+    if (debug)
+    {
+        mTerrainRoot->getOrCreateStateSet()->setAttributeAndModes(new osg::PolygonMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE), osg::StateAttribute::ON);
+        mDebugOccluders = true;
+    }
+    mCollectOccludersVisitor->setMaximumNumberOfActiveOccluders(maximumActive);
+    mCollectOccludersVisitor->setMinimumShadowOccluderVolume(minimumVolume);
+    mOcclusionCullingZFactor = zfactor;
+    mOcclusionCullingZBias = zbias;
 }
 
 QuadTreeWorld::QuadTreeWorld(osg::Group *parent, Storage *storage, int nodeMask, float lodFactor, float chunkSize)
@@ -271,6 +290,67 @@ QuadTreeWorld::~QuadTreeWorld()
 {
 }
 
+void collectOccluders(osg::CollectOccludersVisitor* mCollectOccludersVisitor, osgUtil::CullVisitor* cv, ViewData* vd, bool debug, float zfactor, float zbias)
+{
+    mCollectOccludersVisitor->inheritCullSettings(*cv);
+    mCollectOccludersVisitor->reset();
+    mCollectOccludersVisitor->pushViewport(cv->getViewport());
+    mCollectOccludersVisitor->pushProjectionMatrix(cv->getProjectionMatrix());
+    mCollectOccludersVisitor->pushModelViewMatrix(cv->getModelViewMatrix(),osg::Transform::ABSOLUTE_RF);
+
+    for (unsigned int i=0; i<vd->getNumEntries(); ++i)
+    {
+        ViewData::Entry& entry = vd->getEntry(i);
+        TerrainDrawable* drw = static_cast<TerrainDrawable*>(entry.mRenderingNode->asGroup()->getChild(0));
+
+        float zheight = (drw->getBoundingBox()._min.z() + 1);
+        if (zheight > 0)
+        {
+            float cuttoff = zheight * zfactor + zbias;
+            if (cv->getEyePoint().z() - drw->getBoundingBox()._min.z() > cuttoff)
+                continue;
+        }
+
+        if (debug)
+            drw->getOccluders()->accept(*cv);
+
+        drw->getOccluders()->accept(*mCollectOccludersVisitor);
+    }
+
+    mCollectOccludersVisitor->popModelViewMatrix();
+    mCollectOccludersVisitor->popProjectionMatrix();
+    mCollectOccludersVisitor->popViewport();
+
+    mCollectOccludersVisitor->removeOccludedOccluders();
+
+    if (debug)
+    {
+        static osg::ref_ptr<osg::StateSet> red = nullptr;
+        if (!red) { red = new osg::StateSet;
+        osg::Material* m = new osg::Material;
+        m->setEmission(osg::Material::FRONT_AND_BACK, osg::Vec4f(0,1,0,1));
+        m->setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4f(0,0,0,1));
+        m->setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4f(0,0,0,1));
+        red->setAttributeAndModes(m, osg::StateAttribute::ON|osg::StateAttribute::OVERRIDE);
+        red->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
+        }
+        cv->pushStateSet(red);
+        for (auto svo : mCollectOccludersVisitor->getCollectedOccluderSet())
+        {
+            const osg::NodePath& path = svo.getNodePath();
+            osg::OccluderNode* ocn = static_cast<osg::OccluderNode*>(path.back());
+            ocn->accept(*cv);
+        }
+        cv->popStateSet();
+    }
+
+    if (debug && cv->getTraversalNumber()%50==0)
+        OSG_NOTICE << mCollectOccludersVisitor->getCollectedOccluderSet().size() << " occluders for " << cv->getCurrentCamera()->getName() << std::endl;
+
+    for (auto svo : mCollectOccludersVisitor->getCollectedOccluderSet())
+        cv->getProjectionCullingStack().back().addOccluder(svo);
+}
+
 /// get the level of vertex detail to render this node at, expressed relative to the native resolution of the data set.
 unsigned int getVertexLod(QuadTreeNode* node, int vertexLodMod)
 {
@@ -357,7 +437,7 @@ void loadRenderingNode(ViewData::Entry& entry, ViewData* vd, int vertexLodMod, f
     }
 }
 
-void updateWaterCullingView(HeightCullCallback* callback, ViewData* vd, osgUtil::CullVisitor* cv, float cellworldsize, bool outofworld)
+void updateWaterCullingView(HeightCullCallback* callback, ViewData* vd, osgUtil::CullVisitor* cv, float cellworldsize, bool outofworld, bool debug)
 {
     if (!(cv->getTraversalMask() & callback->getCullMask()))
         return;
@@ -368,8 +448,6 @@ void updateWaterCullingView(HeightCullCallback* callback, ViewData* vd, osgUtil:
         callback->setLowZ(-std::numeric_limits<float>::max());
         return;
     }
-    cv->pushCurrentMask();
-    static bool debug = getenv("OPENMW_WATER_CULLING_DEBUG") != nullptr;
     for (unsigned int i=0; i<vd->getNumEntries(); ++i)
     {
         ViewData::Entry& entry = vd->getEntry(i);
@@ -407,13 +485,12 @@ void updateWaterCullingView(HeightCullCallback* callback, ViewData* vd, osgUtil:
         drw->accept(*cv);
     }
     callback->setLowZ(lowZ);
-    cv->popCurrentMask();
 }
 
 void QuadTreeWorld::accept(osg::NodeVisitor &nv)
 {
-    bool isCullVisitor = nv.getVisitorType() == osg::NodeVisitor::CULL_VISITOR;
-    if (!isCullVisitor && nv.getVisitorType() != osg::NodeVisitor::INTERSECTION_VISITOR)
+    osgUtil::CullVisitor* cv = nv.getVisitorType() == osg::NodeVisitor::CULL_VISITOR ? static_cast<osgUtil::CullVisitor*>(&nv) : nullptr;
+    if (!cv && nv.getVisitorType() != osg::NodeVisitor::INTERSECTION_VISITOR)
     {
         if (nv.getName().find("AcceptedByComponentsTerrainQuadTreeWorld") != std::string::npos)
         {
@@ -428,7 +505,7 @@ void QuadTreeWorld::accept(osg::NodeVisitor &nv)
         return;
     }
 
-    osg::Object * viewer = isCullVisitor ? static_cast<osgUtil::CullVisitor*>(&nv)->getCurrentCamera() : nullptr;
+    osg::Object * viewer = cv ? cv->getCurrentCamera() : nullptr;
     bool needsUpdate = true;
     ViewData *vd = mViewDataMap->getViewData(viewer, nv.getViewPoint(), mActiveGrid, needsUpdate);
 
@@ -445,11 +522,25 @@ void QuadTreeWorld::accept(osg::NodeVisitor &nv)
     {
         ViewData::Entry& entry = vd->getEntry(i);
         loadRenderingNode(entry, vd, mVertexLodMod, cellWorldSize, mActiveGrid, mChunkManagers, false);
+    }
+
+    if (cv && cv->getCullingMode() & osg::CullStack::SHADOW_OCCLUSION_CULLING && mCollectOccludersVisitor)
+    {
+        collectOccluders(mCollectOccludersVisitor, cv, vd, mDebugOccluders, mOcclusionCullingZFactor, mOcclusionCullingZBias);
+        cv->pushCullingSet();
+    }
+
+    if (cv && mCollectOccludersVisitor)
+        updateWaterCullingView(mHeightCullCallback, vd, cv, mStorage->getCellWorldSize(), !isGridEmpty(), mDebugOccluders);
+
+    for (unsigned int i=0; i<vd->getNumEntries(); ++i)
+    {
+        ViewData::Entry& entry = vd->getEntry(i);
         entry.mRenderingNode->accept(nv);
     }
 
-    if (mHeightCullCallback && isCullVisitor)
-        updateWaterCullingView(mHeightCullCallback, vd, static_cast<osgUtil::CullVisitor*>(&nv), mStorage->getCellWorldSize(), !isGridEmpty());
+    if (cv && cv->getCullingMode() & osg::CullStack::SHADOW_OCCLUSION_CULLING && mCollectOccludersVisitor)
+        cv->popCullingSet();
 
     vd->markUnchanged();
 
diff --git a/components/terrain/quadtreeworld.hpp b/components/terrain/quadtreeworld.hpp
index aba2dccf3b..b03806e21f 100644
--- a/components/terrain/quadtreeworld.hpp
+++ b/components/terrain/quadtreeworld.hpp
@@ -9,6 +9,7 @@
 namespace osg
 {
     class NodeVisitor;
+    class CollectOccludersVisitor;
 }
 
 namespace Terrain
@@ -26,6 +27,8 @@ namespace Terrain
 
         ~QuadTreeWorld();
 
+        void setOcclusionCullingSettings(bool debug, int maximumActive, float minimumVolume, float zfactor, float zbias);
+
         void accept(osg::NodeVisitor& nv);
 
         void enable(bool enabled) override;
@@ -64,6 +67,12 @@ namespace Terrain
         std::vector<ChunkManager*> mChunkManagers;
 
         std::mutex mQuadTreeMutex;
+
+        osg::ref_ptr<osg::CollectOccludersVisitor> mCollectOccludersVisitor;
+
+        bool mDebugOccluders;
+        float mOcclusionCullingZFactor;
+        float mOcclusionCullingZBias;
         bool mQuadTreeBuilt;
         float mLodFactor;
         int mVertexLodMod;
diff --git a/components/terrain/terraindrawable.cpp b/components/terrain/terraindrawable.cpp
index 746534abb4..88aaa641f6 100644
--- a/components/terrain/terraindrawable.cpp
+++ b/components/terrain/terraindrawable.cpp
@@ -2,6 +2,8 @@
 
 #include <osg/ClusterCullingCallback>
 #include <osgUtil/CullVisitor>
+#include <osg/OccluderNode>
+#include <osg/Material>
 
 #include <components/sceneutil/lightmanager.hpp>
 
@@ -164,5 +166,95 @@ void TerrainDrawable::compileGLObjects(osg::RenderInfo &renderInfo) const
     osg::Geometry::compileGLObjects(renderInfo);
 }
 
+osg::OccluderNode* createOccluder(const osg::Vec3& v1,const osg::Vec3& v2,const osg::Vec3& v3,const osg::Vec3& v4)
+{
+    osg::ConvexPlanarOccluder* cpo = new osg::ConvexPlanarOccluder;
+    osg::ConvexPlanarPolygon& occluder = cpo->getOccluder();
+    occluder.add(v1);
+    occluder.add(v2);
+    occluder.add(v3);
+    occluder.add(v4);
+    osg::OccluderNode* occluderNode = new osg::OccluderNode;
+    occluderNode->setOccluder(cpo);
+
+    osg::Geometry* debug = new osg::Geometry;
+    osg::Vec3Array* coords = new osg::Vec3Array(occluder.getVertexList().begin(),occluder.getVertexList().end());
+    debug->setVertexArray(coords);
+    debug->setCullingActive(false);
+    debug->addPrimitiveSet(new osg::DrawArrays(osg::PrimitiveSet::QUADS,0,4));
+    static osg::ref_ptr<osg::StateSet> stateset = nullptr;
+    if (!stateset){ stateset = new osg::StateSet;
+    stateset->setMode(GL_CULL_FACE, osg::StateAttribute::OFF);
+    osg::Material* m = new osg::Material;
+    m->setEmission(osg::Material::FRONT_AND_BACK, osg::Vec4f(1,0,0,1));
+      m->setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4f(0,0,0,1));
+        m->setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4f(0,0,0,1));
+        stateset->setAttributeAndModes(m, osg::StateAttribute::ON);
+        stateset->setRenderBinDetails(100,"RenderBin");
+    }
+    debug->setStateSet(stateset);
+
+    occluderNode->addChild(debug);
+
+    return occluderNode;
+}
+
+void TerrainDrawable::createOccluders(const osg::Vec2f& offset)
+{
+    mOccluders = new osg::Group;
+
+    const osg::BoundingBox& mybb = getBoundingBox();
+    const float epsilon = 0.001f;
+    float minz = mybb._min.z() - epsilon;
+    if (minz <= -1) return;
+
+    osg::BoundingBox bb;
+    bb._min = osg::Vec3f(mybb._min.x()+offset.x(), mybb._min.y()+offset.y(), -1);
+    bb._max = osg::Vec3f(mybb._max.x()+offset.x(), mybb._max.y()+offset.y(), minz);
+
+    // bottom side
+    mOccluders->addChild(createOccluder(bb.corner(0),
+                                    bb.corner(2),
+                                    bb.corner(3),
+                                    bb.corner(1)));
+
+    const float sandwichfactor = 0.1;
+    if ((bb._max.z() - bb._min.z()) / (bb._max.x() - bb._min.x()) < sandwichfactor)
+        return;
+
+    // front side
+    mOccluders->addChild(createOccluder(bb.corner(0),
+                                  bb.corner(1),
+                                  bb.corner(5),
+                                  bb.corner(4)));
+    // right side
+    mOccluders->addChild(createOccluder(bb.corner(1),
+                                   bb.corner(3),
+                                  bb.corner(7),
+                                  bb.corner(5)));
+   // left side
+   mOccluders->addChild(createOccluder(bb.corner(2),
+                                  bb.corner(0),
+                                  bb.corner(4),
+                                   bb.corner(6)));
+   // back side
+   mOccluders->addChild(createOccluder(bb.corner(3),
+                                  bb.corner(2),
+                                   bb.corner(6),
+                                  bb.corner(7)));
+
+    // top side
+    mOccluders->addChild(createOccluder(bb.corner(6),
+                                    bb.corner(4),
+                                    bb.corner(5),
+                                    bb.corner(7)));
+
+}
+
+osg::Group* TerrainDrawable::getOccluders()
+{
+    return mOccluders.get();
+}
+
 }
 
diff --git a/components/terrain/terraindrawable.hpp b/components/terrain/terraindrawable.hpp
index dbfdd3c80a..7fc78a20a8 100644
--- a/components/terrain/terraindrawable.hpp
+++ b/components/terrain/terraindrawable.hpp
@@ -58,6 +58,9 @@ namespace Terrain
         void setCompositeMap(CompositeMap* map) { mCompositeMap = map; }
         void setCompositeMapRenderer(CompositeMapRenderer* renderer) { mCompositeMapRenderer = renderer; }
 
+        void createOccluders(const osg::Vec2f& offset);
+        osg::Group* getOccluders();
+
     private:
         osg::BoundingBox mWaterBoundingBox;
         PassVector mPasses;
@@ -67,6 +70,8 @@ namespace Terrain
         osg::ref_ptr<SceneUtil::LightListCallback> mLightListCallback;
         osg::ref_ptr<CompositeMap> mCompositeMap;
         osg::ref_ptr<CompositeMapRenderer> mCompositeMapRenderer;
+
+        osg::ref_ptr<osg::Group> mOccluders;
     };
 
 }
diff --git a/files/settings-default.cfg b/files/settings-default.cfg
index 3660f56f0a..6be74a4796 100644
--- a/files/settings-default.cfg
+++ b/files/settings-default.cfg
@@ -156,6 +156,25 @@ object paging min size cost multiplier = 25
 # Assign a random color to merged batches.
 object paging debug batches = false
 
+# Terrain occlusion culling for main camera
+occlusion culling = true
+
+# Terrain occlusion culling for reflection camera
+reflection occlusion culling = true
+
+# Maximum number of active terrain occluders
+occlusion culling maximum active = 5
+
+# Minimum screen volume ratio for terrain occluders
+occlusion culling minimum volume = 0.05
+
+# Occluders "occluder height * zfactor + zbias" units below the camera will not be used
+occlusion culling zfactor = 3
+occlusion culling zbias = 100
+
+# Visualize occluders (red), active occluders (green), water occludees (blue) and wireframe terrain
+debug occlusion culling = false
+
 [Fog]
 
 # If true, use extended fog parameters for distant terrain not controlled by
-- 
GitLab

